{"version":3,"file":"odo-draggable.js","sources":["../src/settings.js","../src/draggable.js"],"sourcesContent":["import OdoPointer from '@odopod/odo-pointer';\n\nexport default {\n  /** @enum {string} */\n  EventType: {\n    START: 'ododraggable:start',\n    MOVE: 'ododraggable:move',\n    END: 'ododraggable:end',\n    SETTLE: 'ododraggable:throwsettle',\n  },\n\n  Classes: {\n    GRABBABLE: 'grabbable',\n    GRABBING: 'grabbing',\n  },\n\n  Defaults: {\n    // Draggable axis.\n    axis: OdoPointer.Axis.X,\n\n    // Amplifies throw velocity by this value. Higher values make the throwable\n    // travel farther and faster.\n    amplifier: 24,\n\n    // Once the velocity has gone below this threshold, throwing stops.\n    velocityStop: 0.08,\n\n    // On each throw frame, the velocity is multiplied by this friction value.\n    // It must be less than 1. Higher values let the throwable slide farther and longer.\n    throwFriction: 0.94,\n\n    // Whether the draggable will keep its movement momentum after the user releases.\n    isThrowable: false,\n  },\n};\n","import TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport OdoPointer from '@odopod/odo-pointer';\nimport { Coordinate, utilities, math, style } from '@odopod/odo-helpers';\nimport settings from './settings';\n\n/**\n * Throws an error if `condition` is falsy.\n * @param {boolean} condition The condition to test.\n * @param {string} message Error message.\n * @throws {Error} If condition is falsy.\n * @private\n */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Ensure the containing element has a width and height.\n * @param {Object} obj Object to test.\n */\nfunction ensureObjectHasSize(obj) {\n  assert(obj.width > 0, 'containing element\\'s width is zero');\n  assert(obj.height > 0, 'containing element\\'s height is zero');\n}\n\nclass Draggable extends TinyEmitter {\n  constructor(element, options = {}) {\n    super();\n\n    /**\n     * The draggable element.\n     * @type {Element}\n     * @private\n     */\n    this.element = element;\n\n    /**\n     * Override any defaults with the given options.\n     * @type {Object}\n     */\n    this.options = Object.assign({}, Draggable.Defaults, options);\n\n    /**\n     * The element which contains the target.\n     * @type {Element}\n     * @private\n     */\n    this._parentEl = element.parentNode;\n\n    /**\n     * Current position of the handle/target.\n     * @type {Coordinate}\n     * @private\n     */\n    this._currentPosition = new Coordinate();\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     * @private\n     */\n    this._relativeZero = new Coordinate();\n\n    /**\n     * Velocity at which the draggable was thrown. This value decays over time\n     * after a throw.\n     * @private\n     * @type {Coordinate}\n     */\n    this._throwVelocity = new Coordinate();\n\n    /**\n     * The change in position from the start of the drag.\n     * @private\n     * @type {Coordinate}\n     */\n    this._delta = new Coordinate();\n\n    /**\n     * Animation frame id.\n     * @private\n     * @type {number}\n     */\n    this._requestId = 0;\n\n    /**\n     * The size of the containing element. This element is used to determine\n     * the percentage position of the draggable element.\n     * @type {Object}\n     */\n    this._container = { width: 0, height: 0 };\n\n    /**\n     * Limits of how far the draggable element can be dragged.\n     * @type {math.Rect}\n     */\n    this.limits = new math.Rect(NaN, NaN, NaN, NaN);\n\n    this.pointer = new OdoPointer(element, {\n      axis: this.options.axis,\n    });\n\n    this.element.classList.add(Draggable.Classes.GRABBABLE);\n\n    // Kick off.\n    this._listen();\n  }\n\n  _listen() {\n    this._onStart = this._handleDragStart.bind(this);\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    this.pointer.on(OdoPointer.EventType.START, this._onStart);\n    this.pointer.on(OdoPointer.EventType.MOVE, this._onMove);\n    this.pointer.on(OdoPointer.EventType.END, this._onEnd);\n  }\n\n  /**\n   * Saves the containment element's width and height and scrubber position.\n   * @private\n   */\n  _saveDimensions() {\n    this._container = style.getSize(this.element);\n    ensureObjectHasSize(this._container);\n    this._relativeZero = this._getRelativeZero();\n  }\n\n  /**\n   * The position relative to the rest of the page. When it's first\n   * initialized, it is zero zero, but after dragging, it is the position\n   * relative to zero zero.\n   * @return {!Coordinate}\n   * @private\n   */\n  _getRelativeZero() {\n    return Coordinate.difference(\n      this._getDraggablePosition(),\n      this._getOffsetCorrection(),\n    );\n  }\n\n  _getDraggablePosition() {\n    const elRect = this.element.getBoundingClientRect();\n    return new Coordinate(elRect.left, elRect.top);\n  }\n\n  /**\n   * Because the draggable element gets moved around and repositioned,\n   * the bounding client rect method and the offset left and top properties\n   * are unreliable once the element has been dragged once. This method uses\n   * the bounding client rect of the parent element to get a \"correction\"\n   * value.\n   * @return {!Coordinate}\n   * @private\n   */\n  _getOffsetCorrection() {\n    // getBoundingClientRect does not include margins. They must be accounted for.\n    const containmentRect = this._parentEl.getBoundingClientRect();\n    const paddings = style.getPaddingBox(this._parentEl);\n    const margins = style.getMarginBox(this.element);\n    const offsetCorrectionX = margins.left + paddings.left + containmentRect.left;\n    const offsetCorrectionY = margins.top + paddings.top + containmentRect.top;\n    return new Coordinate(offsetCorrectionX, offsetCorrectionY);\n  }\n\n  /**\n   * Sets the current position coordinate to a new coordinate.\n   * @param {Coordinate} position Where the x and y values are a percentage.\n   *     e.g. 50 for \"50%\".\n   */\n  _setCurrentPosition(position) {\n    this.pointer.applyFriction(position);\n    const x = this._limitX((position.x / 100) * this._parentEl.offsetWidth);\n    const y = this._limitY((position.y / 100) * this._parentEl.offsetHeight);\n    this._currentPosition = this._getAxisCoordinate(Math.round(x), Math.round(y));\n  }\n\n  /**\n   * Clamp the x or y value.\n   * @param {number} value X or Y value.\n   * @param {number} rectPosition The limits starting edge. (left or top).\n   * @param {number} rectSize The limits dimension. (width or height).\n   * @return {number} The clamped number.\n   */\n  static _limitValue(value, rectPosition, rectSize) {\n    const side = utilities.defaultsTo(rectPosition, null, !Number.isNaN(rectPosition));\n    const dimension = utilities.defaultsTo(rectSize, 0, !Number.isNaN(rectSize));\n    const max = utilities.defaultsTo(side + dimension, Infinity, side !== null);\n    const min = utilities.defaultsTo(side, -Infinity, side !== null);\n    return math.clamp(value, min, max);\n  }\n\n  /**\n   * Returns the 'real' x after limits are applied (allows for some\n   * limits to be undefined).\n   * @param {number} x X-coordinate to limit.\n   * @return {number} The 'real' X-coordinate after limits are applied.\n   */\n  _limitX(x) {\n    return Draggable._limitValue(x, this.limits.left, this.limits.width);\n  }\n\n  /**\n   * Returns the 'real' y after limits are applied (allows for some\n   * limits to be undefined).\n   * @param {number} y Y-coordinate to limit.\n   * @return {number} The 'real' Y-coordinate after limits are applied.\n   */\n  _limitY(y) {\n    return Draggable._limitValue(y, this.limits.top, this.limits.height);\n  }\n\n  /**\n   * Returns the x and y positions the draggable element should be set to.\n   * @param {Coordinate=} optPosition Position to set the draggable\n   *     element. This will optionally override calculating the position\n   *     from a drag.\n   * @return {!Coordinate} The x and y coordinates.\n   * @private\n   */\n  _getElementPosition(optPosition) {\n    if (optPosition) {\n      this._setCurrentPosition(optPosition);\n    }\n\n    const newX = (this._currentPosition.x / this._container.width) * 100;\n    const newY = (this._currentPosition.y / this._container.height) * 100;\n\n    return this._getAxisCoordinate(newX, newY);\n  }\n\n  /**\n   * Ensures the y value of an x axis draggable is zero and visa versa.\n   * @param {number} newX New position for the x value.\n   * @param {number} newY New position for the y value.\n   * @return {!Coordinate}\n   * @private\n   */\n  _getAxisCoordinate(newX, newY) {\n    // Drag horizontal only.\n    if (this.pointer.isXAxis()) {\n      return new Coordinate(newX, 0);\n    }\n\n    // Drag vertical only.\n    if (this.pointer.isYAxis()) {\n      return new Coordinate(0, newY);\n    }\n\n    // Drag both directions.\n    return new Coordinate(newX, newY);\n  }\n\n  /**\n   * Returns a new coordinate with limits applied to it.\n   * @param {Coordinate} deltaFromStart The distance moved since the drag started.\n   * @return {!Coordinate}\n   * @private\n   */\n  _getNewLimitedPosition(deltaFromStart) {\n    const sum = Coordinate.sum(this._relativeZero, deltaFromStart);\n    return new Coordinate(this._limitX(sum.x), this._limitY(sum.y));\n  }\n\n  /**\n   * Drag start handler.\n   * @private\n   */\n  _handleDragStart(evt) {\n    this._stopThrow();\n    this._saveDimensions();\n    this._currentPosition = this._relativeZero;\n    this._emitEvent(this._createEvent(Draggable.EventType.START, evt));\n    this.element.classList.add(Draggable.Classes.GRABBING);\n  }\n\n  /**\n   * Drag move, after _applyPosition has happened\n   * @param {PointerEvent} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    // Calculate the new position based on limits and the starting point.\n    this._currentPosition = this._getNewLimitedPosition(this.pointer.delta);\n\n    this._emitEvent(this._createEvent(Draggable.EventType.MOVE, evt));\n\n    if (!this.pointer._isDeactivated) {\n      this._applyPosition();\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    this._emitEvent(this._createEvent(Draggable.EventType.END, evt));\n    this.element.classList.remove(Draggable.Classes.GRABBING);\n\n    if (this.options.isThrowable && this.pointer.hasVelocity(evt.currentVelocity, 0)) {\n      this._throw(evt.currentVelocity, evt.delta);\n    }\n  }\n\n  /**\n   * Start a throw based on the draggable's velocity.\n   * @param {Coordinate} velocity Velocity.\n   * @param {Coordinate} delta Total drag distance from start to end.\n   * @private\n   */\n  _throw(velocity, delta) {\n    this._delta = delta;\n    this._throwVelocity = Coordinate.scale(velocity, this.options.amplifier);\n    this._animateThrow();\n  }\n\n  /**\n   * Scale down the velocity, update the position, and apply it. Then do it again\n   * until it's below a threshold.\n   * @private\n   */\n  _animateThrow() {\n    if (this.pointer.hasVelocity(this._throwVelocity, this.options.velocityStop)) {\n      this._currentPosition = this._getNewLimitedPosition(this._delta);\n      this._applyPosition();\n\n      this._delta.translate(this._throwVelocity);\n      this._throwVelocity.scale(this.options.throwFriction);\n\n      // Again!\n      this._requestId = requestAnimationFrame(this._animateThrow.bind(this));\n    } else {\n      // Settle on the pixel grid.\n      this._currentPosition.x = Math.round(this._currentPosition.x);\n      this._currentPosition.y = Math.round(this._currentPosition.y);\n      this._applyPosition();\n      this._emitSettled();\n    }\n  }\n\n  /**\n   * Interrupt a throw.\n   * @private\n   */\n  _stopThrow() {\n    this._delta = new Coordinate();\n    this._throwVelocity = new Coordinate();\n    cancelAnimationFrame(this._requestId);\n  }\n\n  /**\n   * Dispatches the SETTLE event with data. This data is different from the start,\n   * move, and end events which use data from the pointer.\n   * @private\n   */\n  _emitSettled() {\n    this._emitEvent(new OdoPointer.Event({\n      type: Draggable.EventType.SETTLE,\n      target: this.element,\n      axis: this.pointer.axis,\n      deltaTime: Date.now() - this.pointer.startTime,\n      delta: Coordinate.difference(this._relativeZero, this._currentPosition),\n      start: this._relativeZero,\n      end: this._currentPosition,\n      currentVelocity: this._throwVelocity,\n      position: {\n        pixel: this.getPosition(),\n        percent: this.getPosition(true),\n      },\n    }));\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Draggable.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!OdoPointer.Event}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new OdoPointer.Event({\n      type,\n      target: evt.target,\n      currentTarget: this.element,\n      axis: this.pointer.axis,\n      deltaTime: this.pointer.deltaTime,\n      delta: Coordinate.difference(this._currentPosition, this._relativeZero),\n      start: this._relativeZero,\n      end: this._currentPosition,\n      currentVelocity: this.pointer.velocity,\n      position: {\n        pixel: this.getPosition(),\n        percent: this.getPosition(true),\n      },\n    });\n  }\n\n  /**\n   * Sets the position of thd draggable element.\n   * @param {Coordinate} [position] Position to set the draggable element. This\n   *     will optionally override calculating the position from a drag.\n   * @return {Coordinate} The position the draggable element was set to.\n   */\n  _applyPosition(position) {\n    const pos = this._getElementPosition(position);\n    this.element.style[OdoDevice.Dom.TRANSFORM] = `translate(${pos.x}%,${pos.y}%)`;\n    return this._currentPosition;\n  }\n\n  /**\n   * Returns the current position of the draggable element.\n   * @param {boolean} optAsPercent Optionally retrieve percentage values instead\n   *     of pixel values.\n   * @return {Coordinate} X and Y coordinates of the draggable element.\n   */\n  getPosition(optAsPercent) {\n    if (optAsPercent) {\n      return new Coordinate(\n        (this._currentPosition.x / this._parentEl.offsetWidth) * 100,\n        (this._currentPosition.y / this._parentEl.offsetHeight) * 100,\n      );\n    }\n    return this._currentPosition;\n  }\n\n  /**\n   * Set the position of the draggable element.\n   * @param {number} x X position as a percentage. Eg. 50 for \"50%\".\n   * @param {number} y Y position as a percentage. Eg. 50 for \"50%\".\n   * @return {Coordinate} The position the draggable element was set to.\n   */\n  setPosition(x, y) {\n    // setPosition can be called before any dragging, this would cause\n    // the containment width and containment height to be undefined.\n    this.update();\n    return this._applyPosition(new Coordinate(x, y));\n  }\n\n  /**\n   * Sets (or reset) the Drag limits after a Dragger is created.\n   * @param {math.Rect} limits Object containing left, top, width,\n   *     height for new Dragger limits.\n   */\n  setLimits(limits) {\n    this.limits = limits;\n  }\n\n  get friction() {\n    return this.pointer.friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this.pointer.friction = friction;\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this.pointer.isEnabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this.pointer.isEnabled = enabled;\n  }\n\n  /**\n   * Easy way to trigger setting dimensions. Useful for doing things after this\n   * class has been initialized, but no dragging has occurred yet.\n   */\n  update() {\n    this._saveDimensions();\n  }\n\n  /**\n   * Remove event listeners and element references.\n   * @private\n   */\n  dispose() {\n    this.pointer.off(OdoPointer.EventType.START, this._onStart);\n    this.pointer.off(OdoPointer.EventType.MOVE, this._onMove);\n    this.pointer.off(OdoPointer.EventType.END, this._onEnd);\n\n    this.pointer.dispose();\n\n    this.element.classList.remove(Draggable.Classes.GRABBABLE);\n\n    this._parentEl = null;\n    this.element = null;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n}\n\nObject.assign(Draggable, settings);\n\nexport default Draggable;\n"],"names":["OdoPointer","Axis","X","assert","condition","message","Error","ensureObjectHasSize","obj","width","height","Draggable","element","options","Object","assign","Defaults","_parentEl","parentNode","_currentPosition","Coordinate","_relativeZero","_throwVelocity","_delta","_requestId","_container","limits","math","Rect","NaN","pointer","axis","classList","add","Classes","GRABBABLE","_listen","_onStart","_handleDragStart","bind","_onMove","_handleDragMove","_onEnd","_handleDragEnd","on","EventType","START","MOVE","END","_saveDimensions","style","getSize","_getRelativeZero","difference","_getDraggablePosition","_getOffsetCorrection","elRect","getBoundingClientRect","left","top","containmentRect","paddings","getPaddingBox","margins","getMarginBox","offsetCorrectionX","offsetCorrectionY","_setCurrentPosition","position","applyFriction","x","_limitX","offsetWidth","y","_limitY","offsetHeight","_getAxisCoordinate","Math","round","_limitValue","value","rectPosition","rectSize","side","utilities","defaultsTo","Number","isNaN","dimension","max","Infinity","min","clamp","_getElementPosition","optPosition","newX","newY","isXAxis","isYAxis","_getNewLimitedPosition","deltaFromStart","sum","evt","_stopThrow","_emitEvent","_createEvent","GRABBING","delta","_isDeactivated","_applyPosition","remove","isThrowable","hasVelocity","currentVelocity","_throw","velocity","scale","amplifier","_animateThrow","velocityStop","translate","throwFriction","requestAnimationFrame","_emitSettled","Event","SETTLE","Date","now","startTime","getPosition","type","target","deltaTime","pos","OdoDevice","Dom","TRANSFORM","optAsPercent","setPosition","update","setLimits","dispose","off","event","emit","defaultPrevented","friction","isEnabled","enabled","TinyEmitter","settings"],"mappings":"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"}