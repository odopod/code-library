{"version":3,"file":"odo-affix.js","sources":["../src/affix.js"],"sourcesContent":["/**\n * @fileoverview Emulates `position:sticky` to make an element fixed position\n * while its within a container. This is best for sidebars so that they follow\n * the content, without overlapping sections below it.\n */\n\nimport OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\n\nclass Affix {\n  constructor(element) {\n    /**\n     * Main element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Parent containing element.\n     * @type {Element}\n     */\n    this._anchor = document.getElementById(element.getAttribute('data-anchor'));\n\n    if (!this._anchor) {\n      throw new Error(`Unable to find element with id=\"${element.getAttribute('data-anchor')}\"`);\n    }\n\n    /**\n     * Whether the main element is position fixed.\n     * @type {boolean}\n     */\n    this.isStuck = false;\n\n    /**\n     * Whether the main element is stuck to the bottom of its container.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the main element has been promoted to its own layer for the GPU.\n     * @type {boolean}\n     * @protected\n     */\n    this.isPromoted = false;\n\n    /**\n     * Custom overlap getter. Can be overridden by setting `uiOverlap`.\n     * @type {?function}\n     * @private\n     */\n    this._customOverlap = null;\n\n    /**\n     * Current UI overlap.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Current maximum height for the main sticky element.\n     * @type {number}\n     * @private\n     */\n    this._maxHeight = 0;\n\n    /**\n     * Main element's top margin.\n     * @type {number}\n     * @private\n     */\n    this._marginTop = 0;\n\n    /**\n     * Main element's bottom margin.\n     * @type {number}\n     * @private\n     */\n    this._marginBottom = 0;\n\n    /**\n     * Top offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._top = 0;\n\n    /**\n     * Bottom offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._bottom = 0;\n\n    /**\n     * Height of the anchor (container).\n     * @type {number}\n     */\n    this.containerHeight = 0;\n\n    /**\n     * Unique id for the throttled scroll event listener.\n     * @type {string}\n     * @private\n     */\n    this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n\n    this.element.classList.add(Affix.Classes.BASE);\n    this.element.style.overflowY = 'auto';\n\n    // Keep track of instances so they can be batch-processed.\n    Affix.instances.push(this);\n\n    this.update();\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   * @protected\n   */\n  read() {\n    const rect = this._anchor.getBoundingClientRect();\n    const scrollY = window.pageYOffset;\n    const viewportHeight = window.innerHeight;\n    const asideHeight = this.element.offsetHeight;\n    this._asideWidth = this.element.offsetWidth;\n    const styles = getComputedStyle(this.element, null);\n    this._marginTop = parseFloat(styles.marginTop);\n    this._marginBottom = parseFloat(styles.marginBottom);\n\n    this._overlap = this.uiOverlap;\n    this._maxHeight = viewportHeight - this._overlap - this._marginTop - this._marginBottom;\n\n    this.containerHeight = Math.round(rect.height);\n    this._top = rect.top + scrollY;\n    this._bottom = rect.bottom + scrollY - Math.min(asideHeight, this._maxHeight);\n  }\n\n  /** @protected */\n  write() {\n    this.element.style.maxHeight = this._maxHeight + 'px';\n    this.element.style.width = this._asideWidth + 'px';\n  }\n\n  /**\n   * This method runs on every frame to update the placement of the sticky element.\n   * @param {number} scrollTop Scroll top of the page.\n   */\n  process(scrollTop = window.pageYOffset) {\n    // Stick (position fixed).\n    if ((!this.isStuck && scrollTop >= this.top && scrollTop < this.bottom) ||\n        (this.isAtBottom && scrollTop < this.bottom)) {\n      this.stick();\n\n    // Affix. Item has reached the end of its view-length, stick it to the bottom.\n    } else if (!this.isAtBottom && scrollTop >= this.bottom) {\n      this.stickToBottom();\n\n    // Above the position where the sticky element should be position fixed, so unstick it.\n    } else if (this.isStuck && scrollTop < this.top) {\n      this.unstick();\n    }\n\n    // When the affix-element's position is soon going to change, promote it\n    // to a new layer so that the browser does not have to paint it on every scroll.\n    // Having the affix-element layer promoted all the time is inefficient and greedy.\n    const isInRange = this.isInPromotionRange(scrollTop);\n    if (!this.isPromoted && isInRange) {\n      this.layerPromote();\n    } else if (this.isPromoted && !isInRange) {\n      this.layerDemote();\n    }\n  }\n\n  isInPromotionRange(scrollTop) {\n    return scrollTop >= this.top - Affix.PROMOTION_RANGE &&\n        scrollTop <= this.bottom + Affix.PROMOTION_RANGE;\n  }\n\n  /** @protected */\n  stick() {\n    this.element.style.position = 'fixed';\n    this.element.style.top = Math.round(this._overlap) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.isStuck = true;\n    this.isAtBottom = false;\n  }\n\n  /** @protected */\n  stickToBottom() {\n    this.element.style.position = 'absolute';\n    this.element.style.top = Math.round(this._bottom - this._top - this._marginBottom) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.element.classList.add(Affix.Classes.AT_BOTTOM);\n    this.isAtBottom = true;\n  }\n\n  /** @protected */\n  unstick() {\n    this.element.style.position = '';\n    this.element.classList.add(Affix.Classes.AT_TOP);\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.isStuck = false;\n    this.isAtBottom = false;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   * @protected\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   * @protected\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Reset values that are set with `write` so that they can be read again.\n   * @protected\n   */\n  reset() {\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n  }\n\n  /**\n   * The amount that the ui overlaps the top of the page. A sticky navigation,\n   * for example, would cause an overlap equal to its height.\n   * @return {number}\n   */\n  get uiOverlap() {\n    if (this._customOverlap) {\n      return this._customOverlap();\n    }\n\n    return 0;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._customOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * The offset when this component becomes sticky.\n   * @return {number}\n   */\n  get top() {\n    return this._top - this._overlap;\n  }\n\n  /**\n   * The offset when this component sticks to the bottom of its container.\n   * @return {number}\n   */\n  get bottom() {\n    return this._bottom - this._marginBottom;\n  }\n\n  /**\n   * Reset everything, cache offsets, and recalculate.\n   */\n  update() {\n    const scrollTop = this.element.scrollTop;\n    this.unstick();\n    this.reset();\n    this.read();\n    this.write();\n    this.process();\n    this.element.scrollTop = scrollTop;\n  }\n\n  /**\n   * Remove event listeners and references.\n   */\n  dispose() {\n    this.layerDemote();\n    this.element.classList.remove(Affix.Classes.BASE);\n    this.element.style.position = '';\n    this.element.style.top = '';\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n    this.element.style.overflowY = '';\n    this.element = null;\n    this._anchor = null;\n    OdoWindowEvents.remove(this._resizeId);\n    OdoScrollAnimation.remove(this._scrollId);\n    Affix.arrayRemove(Affix.instances, this);\n  }\n\n  /**\n   * Since 'load' events on images do not bubble, the event listener cannot be\n   * delegated and must be added to every image.\n   * The load event is not removed once the image loads because the image could\n   * be a responsive image which could have multiple load events.\n   */\n  static _addImageLoadHandlers() {\n    const images = document.getElementsByTagName('img');\n\n    for (let i = 0, len = images.length; i < len; i++) {\n      images[i].addEventListener('load', Affix._scheduleUpdate, false);\n    }\n  }\n\n  /**\n   * Schedule a throttled update to check if offsets need to be recalculated.\n   */\n  static _scheduleUpdate() {\n    window.removeEventListener('load', Affix._scheduleUpdate);\n\n    // Cancel a previous update if it exists.\n    if (Affix._updateId) {\n      window.cancelAnimationFrame(Affix._updateId);\n    }\n\n    // Throttle updates to once per frame.\n    Affix._updateId = window.requestAnimationFrame(Affix._handleImageLoad);\n  }\n\n  /**\n   * When an image loads, it could possibly change the layout/geometry of the\n   * entire page. Because Affix relies on offsets, everything must be\n   * updated here.\n   */\n  static _handleImageLoad() {\n    Affix._updateId = null;\n    Affix.documentHeight = document.body.offsetHeight;\n    Affix.viewportHeight = window.innerHeight;\n    Affix.update();\n  }\n\n  /**\n   * Batch update all instances. This method is more efficient because it syncs\n   * reads and writes to the DOM for each instance.\n   */\n  static update() {\n    const scrollY = window.pageYOffset;\n    const scrollPositions = Affix.instances.map(instance => instance.element.scrollTop);\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.unstick();\n      instance.reset();\n    });\n\n    // Read\n    Affix.instances.forEach((instance) => {\n      instance.read();\n    });\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.write();\n      instance.process(scrollY);\n    });\n\n    Affix.instances.forEach((instance, i) => {\n      instance.element.scrollTop = scrollPositions[i];\n    });\n  }\n\n  /**\n   * Remove an item from an array.\n   * @param {Array} arr Array to use.\n   * @param {*} item Item to remove.\n   * @return {*} Item removed.\n   */\n  static arrayRemove(arr, item) {\n    const index = arr.indexOf(item);\n    arr.splice(index, 1);\n    return item;\n  }\n}\n\nAffix.PROMOTION_RANGE = 200;\nAffix.instances = [];\nAffix._updateId = null;\nAffix.documentHeight = document.body.offsetHeight;\nAffix.viewportHeight = window.innerHeight;\nAffix._addImageLoadHandlers();\nAffix._resizeId = OdoWindowEvents.onResize(Affix._scheduleUpdate);\nwindow.addEventListener('load', Affix._scheduleUpdate);\n\nAffix.Classes = {\n  BASE: 'odo-affix',\n  AT_TOP: 'odo-affix--at-top',\n  AT_BOTTOM: 'odo-affix--at-bottom',\n};\n\nexport default Affix;\n"],"names":["Affix","element","_anchor","document","getElementById","getAttribute","Error","isStuck","isAtBottom","isPromoted","_customOverlap","_overlap","_maxHeight","_marginTop","_marginBottom","_top","_bottom","containerHeight","_scrollId","OdoScrollAnimation","add","process","bind","classList","Classes","BASE","style","overflowY","instances","push","update","read","rect","getBoundingClientRect","scrollY","window","pageYOffset","viewportHeight","innerHeight","asideHeight","offsetHeight","_asideWidth","offsetWidth","styles","getComputedStyle","parseFloat","marginTop","marginBottom","uiOverlap","Math","round","height","top","bottom","min","write","maxHeight","width","scrollTop","stick","stickToBottom","unstick","isInRange","isInPromotionRange","layerPromote","layerDemote","PROMOTION_RANGE","position","remove","AT_BOTTOM","AT_TOP","willChange","transform","reset","dispose","_resizeId","arrayRemove","_addImageLoadHandlers","images","getElementsByTagName","i","len","length","addEventListener","_scheduleUpdate","removeEventListener","_updateId","cancelAnimationFrame","requestAnimationFrame","_handleImageLoad","documentHeight","body","scrollPositions","map","instance","forEach","arr","item","index","indexOf","splice","fn","OdoWindowEvents","onResize"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;AAMA,IAGMA;iBACQC,OAAZ,EAAqB;;;;;;;SAKdA,OAAL,GAAeA,OAAf;;;;;;SAMKC,OAAL,GAAeC,SAASC,cAAT,CAAwBH,QAAQI,YAAR,CAAqB,aAArB,CAAxB,CAAf;;QAEI,CAAC,KAAKH,OAAV,EAAmB;YACX,IAAII,KAAJ,sCAA6CL,QAAQI,YAAR,CAAqB,aAArB,CAA7C,OAAN;;;;;;;SAOGE,OAAL,GAAe,KAAf;;;;;;SAMKC,UAAL,GAAkB,KAAlB;;;;;;;SAOKC,UAAL,GAAkB,KAAlB;;;;;;;SAOKC,cAAL,GAAsB,IAAtB;;;;;;;SAOKC,QAAL,GAAgB,CAAhB;;;;;;;SAOKC,UAAL,GAAkB,CAAlB;;;;;;;SAOKC,UAAL,GAAkB,CAAlB;;;;;;;SAOKC,aAAL,GAAqB,CAArB;;;;;;;SAOKC,IAAL,GAAY,CAAZ;;;;;;;SAOKC,OAAL,GAAe,CAAf;;;;;;SAMKC,eAAL,GAAuB,CAAvB;;;;;;;SAOKC,SAAL,GAAiBC,mBAAmBC,GAAnB,CAAuB,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAvB,CAAjB;;SAEKrB,OAAL,CAAasB,SAAb,CAAuBH,GAAvB,CAA2BpB,MAAMwB,OAAN,CAAcC,IAAzC;SACKxB,OAAL,CAAayB,KAAb,CAAmBC,SAAnB,GAA+B,MAA/B;;;UAGMC,SAAN,CAAgBC,IAAhB,CAAqB,IAArB;;SAEKC,MAAL;;;;;;;;;kBAOFC,uBAAO;QACCC,OAAO,KAAK9B,OAAL,CAAa+B,qBAAb,EAAb;QACMC,UAAUC,OAAOC,WAAvB;QACMC,iBAAiBF,OAAOG,WAA9B;QACMC,cAAc,KAAKtC,OAAL,CAAauC,YAAjC;SACKC,WAAL,GAAmB,KAAKxC,OAAL,CAAayC,WAAhC;QACMC,SAASC,iBAAiB,KAAK3C,OAAtB,EAA+B,IAA/B,CAAf;SACKY,UAAL,GAAkBgC,WAAWF,OAAOG,SAAlB,CAAlB;SACKhC,aAAL,GAAqB+B,WAAWF,OAAOI,YAAlB,CAArB;;SAEKpC,QAAL,GAAgB,KAAKqC,SAArB;SACKpC,UAAL,GAAkByB,iBAAiB,KAAK1B,QAAtB,GAAiC,KAAKE,UAAtC,GAAmD,KAAKC,aAA1E;;SAEKG,eAAL,GAAuBgC,KAAKC,KAAL,CAAWlB,KAAKmB,MAAhB,CAAvB;SACKpC,IAAL,GAAYiB,KAAKoB,GAAL,GAAWlB,OAAvB;SACKlB,OAAL,GAAegB,KAAKqB,MAAL,GAAcnB,OAAd,GAAwBe,KAAKK,GAAL,CAASf,WAAT,EAAsB,KAAK3B,UAA3B,CAAvC;;;;;;kBAIF2C,yBAAQ;SACDtD,OAAL,CAAayB,KAAb,CAAmB8B,SAAnB,GAA+B,KAAK5C,UAAL,GAAkB,IAAjD;SACKX,OAAL,CAAayB,KAAb,CAAmB+B,KAAnB,GAA2B,KAAKhB,WAAL,GAAmB,IAA9C;;;;;;;;;kBAOFpB,6BAAwC;QAAhCqC,SAAgC,uEAApBvB,OAAOC,WAAa;;;QAEjC,CAAC,KAAK7B,OAAN,IAAiBmD,aAAa,KAAKN,GAAnC,IAA0CM,YAAY,KAAKL,MAA5D,IACC,KAAK7C,UAAL,IAAmBkD,YAAY,KAAKL,MADzC,EACkD;WAC3CM,KAAL;;;KAFF,MAKO,IAAI,CAAC,KAAKnD,UAAN,IAAoBkD,aAAa,KAAKL,MAA1C,EAAkD;WAClDO,aAAL;;;KADK,MAIA,IAAI,KAAKrD,OAAL,IAAgBmD,YAAY,KAAKN,GAArC,EAA0C;WAC1CS,OAAL;;;;;;QAMIC,YAAY,KAAKC,kBAAL,CAAwBL,SAAxB,CAAlB;QACI,CAAC,KAAKjD,UAAN,IAAoBqD,SAAxB,EAAmC;WAC5BE,YAAL;KADF,MAEO,IAAI,KAAKvD,UAAL,IAAmB,CAACqD,SAAxB,EAAmC;WACnCG,WAAL;;;;kBAIJF,iDAAmBL,WAAW;WACrBA,aAAa,KAAKN,GAAL,GAAWpD,MAAMkE,eAA9B,IACHR,aAAa,KAAKL,MAAL,GAAcrD,MAAMkE,eADrC;;;;;;kBAKFP,yBAAQ;SACD1D,OAAL,CAAayB,KAAb,CAAmByC,QAAnB,GAA8B,OAA9B;SACKlE,OAAL,CAAayB,KAAb,CAAmB0B,GAAnB,GAAyBH,KAAKC,KAAL,CAAW,KAAKvC,QAAhB,IAA4B,IAArD;SACKV,OAAL,CAAasB,SAAb,CAAuB6C,MAAvB,CAA8BpE,MAAMwB,OAAN,CAAc6C,SAA5C;SACKpE,OAAL,CAAasB,SAAb,CAAuB6C,MAAvB,CAA8BpE,MAAMwB,OAAN,CAAc8C,MAA5C;SACK/D,OAAL,GAAe,IAAf;SACKC,UAAL,GAAkB,KAAlB;;;;;;kBAIFoD,yCAAgB;SACT3D,OAAL,CAAayB,KAAb,CAAmByC,QAAnB,GAA8B,UAA9B;SACKlE,OAAL,CAAayB,KAAb,CAAmB0B,GAAnB,GAAyBH,KAAKC,KAAL,CAAW,KAAKlC,OAAL,GAAe,KAAKD,IAApB,GAA2B,KAAKD,aAA3C,IAA4D,IAArF;SACKb,OAAL,CAAasB,SAAb,CAAuB6C,MAAvB,CAA8BpE,MAAMwB,OAAN,CAAc8C,MAA5C;SACKrE,OAAL,CAAasB,SAAb,CAAuBH,GAAvB,CAA2BpB,MAAMwB,OAAN,CAAc6C,SAAzC;SACK7D,UAAL,GAAkB,IAAlB;;;;;;kBAIFqD,6BAAU;SACH5D,OAAL,CAAayB,KAAb,CAAmByC,QAAnB,GAA8B,EAA9B;SACKlE,OAAL,CAAasB,SAAb,CAAuBH,GAAvB,CAA2BpB,MAAMwB,OAAN,CAAc8C,MAAzC;SACKrE,OAAL,CAAasB,SAAb,CAAuB6C,MAAvB,CAA8BpE,MAAMwB,OAAN,CAAc6C,SAA5C;SACK9D,OAAL,GAAe,KAAf;SACKC,UAAL,GAAkB,KAAlB;;;;;;;;;kBAOFwD,uCAAe;SACR/D,OAAL,CAAayB,KAAb,CAAmB6C,UAAnB,GAAgC,UAAhC;SACKtE,OAAL,CAAayB,KAAb,CAAmB8C,SAAnB,GAA+B,eAA/B;SACK/D,UAAL,GAAkB,IAAlB;;;;;;;;;kBAOFwD,qCAAc;SACPhE,OAAL,CAAayB,KAAb,CAAmB6C,UAAnB,GAAgC,EAAhC;SACKtE,OAAL,CAAayB,KAAb,CAAmB8C,SAAnB,GAA+B,EAA/B;SACK/D,UAAL,GAAkB,KAAlB;;;;;;;;;kBAOFgE,yBAAQ;SACDxE,OAAL,CAAayB,KAAb,CAAmB8B,SAAnB,GAA+B,EAA/B;SACKvD,OAAL,CAAayB,KAAb,CAAmB+B,KAAnB,GAA2B,EAA3B;;;;;;;;;;;;;kBA4CF3B,2BAAS;QACD4B,YAAY,KAAKzD,OAAL,CAAayD,SAA/B;SACKG,OAAL;SACKY,KAAL;SACK1C,IAAL;SACKwB,KAAL;SACKlC,OAAL;SACKpB,OAAL,CAAayD,SAAb,GAAyBA,SAAzB;;;;;;;;kBAMFgB,6BAAU;SACHT,WAAL;SACKhE,OAAL,CAAasB,SAAb,CAAuB6C,MAAvB,CAA8BpE,MAAMwB,OAAN,CAAcC,IAA5C;SACKxB,OAAL,CAAayB,KAAb,CAAmByC,QAAnB,GAA8B,EAA9B;SACKlE,OAAL,CAAayB,KAAb,CAAmB0B,GAAnB,GAAyB,EAAzB;SACKnD,OAAL,CAAayB,KAAb,CAAmB8B,SAAnB,GAA+B,EAA/B;SACKvD,OAAL,CAAayB,KAAb,CAAmB+B,KAAnB,GAA2B,EAA3B;SACKxD,OAAL,CAAayB,KAAb,CAAmBC,SAAnB,GAA+B,EAA/B;SACK1B,OAAL,GAAe,IAAf;SACKC,OAAL,GAAe,IAAf;oBACgBkE,MAAhB,CAAuB,KAAKO,SAA5B;uBACmBP,MAAnB,CAA0B,KAAKlD,SAA/B;UACM0D,WAAN,CAAkB5E,MAAM4B,SAAxB,EAAmC,IAAnC;;;;;;;;;;;QASKiD,yDAAwB;QACvBC,SAAS3E,SAAS4E,oBAAT,CAA8B,KAA9B,CAAf;;SAEK,IAAIC,IAAI,CAAR,EAAWC,MAAMH,OAAOI,MAA7B,EAAqCF,IAAIC,GAAzC,EAA8CD,GAA9C,EAAmD;aAC1CA,CAAP,EAAUG,gBAAV,CAA2B,MAA3B,EAAmCnF,MAAMoF,eAAzC,EAA0D,KAA1D;;;;;;;;;QAOGA,6CAAkB;WAChBC,mBAAP,CAA2B,MAA3B,EAAmCrF,MAAMoF,eAAzC;;;QAGIpF,MAAMsF,SAAV,EAAqB;aACZC,oBAAP,CAA4BvF,MAAMsF,SAAlC;;;;UAIIA,SAAN,GAAkBnD,OAAOqD,qBAAP,CAA6BxF,MAAMyF,gBAAnC,CAAlB;;;;;;;;;;QAQKA,+CAAmB;UAClBH,SAAN,GAAkB,IAAlB;UACMI,cAAN,GAAuBvF,SAASwF,IAAT,CAAcnD,YAArC;UACMH,cAAN,GAAuBF,OAAOG,WAA9B;UACMR,MAAN;;;;;;;;;QAOKA,2BAAS;QACRI,UAAUC,OAAOC,WAAvB;QACMwD,kBAAkB5F,MAAM4B,SAAN,CAAgBiE,GAAhB,CAAoB;aAAYC,SAAS7F,OAAT,CAAiByD,SAA7B;KAApB,CAAxB;;;UAGM9B,SAAN,CAAgBmE,OAAhB,CAAwB,UAACD,QAAD,EAAc;eAC3BjC,OAAT;eACSY,KAAT;KAFF;;;UAMM7C,SAAN,CAAgBmE,OAAhB,CAAwB,UAACD,QAAD,EAAc;eAC3B/D,IAAT;KADF;;;UAKMH,SAAN,CAAgBmE,OAAhB,CAAwB,UAACD,QAAD,EAAc;eAC3BvC,KAAT;eACSlC,OAAT,CAAiBa,OAAjB;KAFF;;UAKMN,SAAN,CAAgBmE,OAAhB,CAAwB,UAACD,QAAD,EAAWd,CAAX,EAAiB;eAC9B/E,OAAT,CAAiByD,SAAjB,GAA6BkC,gBAAgBZ,CAAhB,CAA7B;KADF;;;;;;;;;;;QAWKJ,mCAAYoB,KAAKC,MAAM;QACtBC,QAAQF,IAAIG,OAAJ,CAAYF,IAAZ,CAAd;QACIG,MAAJ,CAAWF,KAAX,EAAkB,CAAlB;WACOD,IAAP;;;;;wBAhJc;UACV,KAAKvF,cAAT,EAAyB;eAChB,KAAKA,cAAL,EAAP;;;aAGK,CAAP;;;;;;;;sBAOY2F,IAAI;WACX3F,cAAL,GAAsB2F,EAAtB;WACKvE,MAAL;;;;;;;;;;wBAOQ;aACD,KAAKf,IAAL,GAAY,KAAKJ,QAAxB;;;;;;;;;;wBAOW;aACJ,KAAKK,OAAL,GAAe,KAAKF,aAA3B;;;;;;AAsHJd,MAAMkE,eAAN,GAAwB,GAAxB;AACAlE,MAAM4B,SAAN,GAAkB,EAAlB;AACA5B,MAAMsF,SAAN,GAAkB,IAAlB;AACAtF,MAAM0F,cAAN,GAAuBvF,SAASwF,IAAT,CAAcnD,YAArC;AACAxC,MAAMqC,cAAN,GAAuBF,OAAOG,WAA9B;AACAtC,MAAM6E,qBAAN;AACA7E,MAAM2E,SAAN,GAAkB2B,gBAAgBC,QAAhB,CAAyBvG,MAAMoF,eAA/B,CAAlB;AACAjD,OAAOgD,gBAAP,CAAwB,MAAxB,EAAgCnF,MAAMoF,eAAtC;;AAEApF,MAAMwB,OAAN,GAAgB;QACR,WADQ;UAEN,mBAFM;aAGH;CAHb;;;;;;;;"}