{"version":3,"file":"odo-affix.min.js","sources":["../src/affix.js"],"sourcesContent":["/**\n * @fileoverview Emulates `position:sticky` to make an element fixed position\n * while its within a container. This is best for sidebars so that they follow\n * the content, without overlapping sections below it.\n */\n\nimport OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\n\nclass Affix {\n  constructor(element) {\n    /**\n     * Main element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Parent containing element.\n     * @type {Element}\n     */\n    this._anchor = document.getElementById(element.getAttribute('data-anchor'));\n\n    if (!this._anchor) {\n      throw new Error(`Unable to find element with id=\"${element.getAttribute('data-anchor')}\"`);\n    }\n\n    /**\n     * Whether the main element is position fixed.\n     * @type {boolean}\n     */\n    this.isStuck = false;\n\n    /**\n     * Whether the main element is stuck to the bottom of its container.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the main element has been promoted to its own layer for the GPU.\n     * @type {boolean}\n     * @protected\n     */\n    this.isPromoted = false;\n\n    /**\n     * Custom overlap getter. Can be overridden by setting `uiOverlap`.\n     * @type {?function}\n     * @private\n     */\n    this._customOverlap = null;\n\n    /**\n     * Current UI overlap.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Current maximum height for the main sticky element.\n     * @type {number}\n     * @private\n     */\n    this._maxHeight = 0;\n\n    /**\n     * Main element's top margin.\n     * @type {number}\n     * @private\n     */\n    this._marginTop = 0;\n\n    /**\n     * Main element's bottom margin.\n     * @type {number}\n     * @private\n     */\n    this._marginBottom = 0;\n\n    /**\n     * Top offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._top = 0;\n\n    /**\n     * Bottom offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._bottom = 0;\n\n    /**\n     * Height of the anchor (container).\n     * @type {number}\n     */\n    this.containerHeight = 0;\n\n    /**\n     * Unique id for the throttled scroll event listener.\n     * @type {string}\n     * @private\n     */\n    this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n\n    this.element.classList.add(Affix.Classes.BASE);\n    this.element.style.overflowY = 'auto';\n\n    // Keep track of instances so they can be batch-processed.\n    Affix.instances.push(this);\n\n    this.update();\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   * @protected\n   */\n  read() {\n    const rect = this._anchor.getBoundingClientRect();\n    const scrollY = window.pageYOffset;\n    const viewportHeight = window.innerHeight;\n    const asideHeight = this.element.offsetHeight;\n    this._asideWidth = this.element.offsetWidth;\n    const styles = getComputedStyle(this.element, null);\n    this._marginTop = parseFloat(styles.marginTop);\n    this._marginBottom = parseFloat(styles.marginBottom);\n\n    this._overlap = this.uiOverlap;\n    this._maxHeight = viewportHeight - this._overlap - this._marginTop - this._marginBottom;\n\n    this.containerHeight = Math.round(rect.height);\n    this._top = rect.top + scrollY;\n    this._bottom = rect.bottom + scrollY - Math.min(asideHeight, this._maxHeight);\n  }\n\n  /** @protected */\n  write() {\n    this.element.style.maxHeight = this._maxHeight + 'px';\n    this.element.style.width = this._asideWidth + 'px';\n  }\n\n  /**\n   * This method runs on every frame to update the placement of the sticky element.\n   * @param {number} scrollTop Scroll top of the page.\n   */\n  process(scrollTop = window.pageYOffset) {\n    // Stick (position fixed).\n    if ((!this.isStuck && scrollTop >= this.top && scrollTop < this.bottom) ||\n        (this.isAtBottom && scrollTop < this.bottom)) {\n      this.stick();\n\n    // Affix. Item has reached the end of its view-length, stick it to the bottom.\n    } else if (!this.isAtBottom && scrollTop >= this.bottom) {\n      this.stickToBottom();\n\n    // Above the position where the sticky element should be position fixed, so unstick it.\n    } else if (this.isStuck && scrollTop < this.top) {\n      this.unstick();\n    }\n\n    // When the affix-element's position is soon going to change, promote it\n    // to a new layer so that the browser does not have to paint it on every scroll.\n    // Having the affix-element layer promoted all the time is inefficient and greedy.\n    const isInRange = this.isInPromotionRange(scrollTop);\n    if (!this.isPromoted && isInRange) {\n      this.layerPromote();\n    } else if (this.isPromoted && !isInRange) {\n      this.layerDemote();\n    }\n  }\n\n  isInPromotionRange(scrollTop) {\n    return scrollTop >= this.top - Affix.PROMOTION_RANGE &&\n        scrollTop <= this.bottom + Affix.PROMOTION_RANGE;\n  }\n\n  /** @protected */\n  stick() {\n    this.element.style.position = 'fixed';\n    this.element.style.top = Math.round(this._overlap) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.isStuck = true;\n    this.isAtBottom = false;\n  }\n\n  /** @protected */\n  stickToBottom() {\n    this.element.style.position = 'absolute';\n    this.element.style.top = Math.round(this._bottom - this._top - this._marginBottom) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.element.classList.add(Affix.Classes.AT_BOTTOM);\n    this.isAtBottom = true;\n  }\n\n  /** @protected */\n  unstick() {\n    this.element.style.position = '';\n    this.element.classList.add(Affix.Classes.AT_TOP);\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.isStuck = false;\n    this.isAtBottom = false;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   * @protected\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   * @protected\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Reset values that are set with `write` so that they can be read again.\n   * @protected\n   */\n  reset() {\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n  }\n\n  /**\n   * The amount that the ui overlaps the top of the page. A sticky navigation,\n   * for example, would cause an overlap equal to its height.\n   * @return {number}\n   */\n  get uiOverlap() {\n    if (this._customOverlap) {\n      return this._customOverlap();\n    }\n\n    return 0;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._customOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * The offset when this component becomes sticky.\n   * @return {number}\n   */\n  get top() {\n    return this._top - this._overlap;\n  }\n\n  /**\n   * The offset when this component sticks to the bottom of its container.\n   * @return {number}\n   */\n  get bottom() {\n    return this._bottom - this._marginBottom;\n  }\n\n  /**\n   * Reset everything, cache offsets, and recalculate.\n   */\n  update() {\n    const { scrollTop } = this.element;\n    this.unstick();\n    this.reset();\n    this.read();\n    this.write();\n    this.process();\n    this.element.scrollTop = scrollTop;\n  }\n\n  /**\n   * Remove event listeners and references.\n   */\n  dispose() {\n    this.layerDemote();\n    this.element.classList.remove(Affix.Classes.BASE);\n    this.element.style.position = '';\n    this.element.style.top = '';\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n    this.element.style.overflowY = '';\n    this.element = null;\n    this._anchor = null;\n    OdoWindowEvents.remove(this._resizeId);\n    OdoScrollAnimation.remove(this._scrollId);\n    Affix.arrayRemove(Affix.instances, this);\n  }\n\n  /**\n   * Since 'load' events on images do not bubble, the event listener cannot be\n   * delegated and must be added to every image.\n   * The load event is not removed once the image loads because the image could\n   * be a responsive image which could have multiple load events.\n   */\n  static _addImageLoadHandlers() {\n    const images = document.getElementsByTagName('img');\n\n    for (let i = 0, len = images.length; i < len; i++) {\n      images[i].addEventListener('load', Affix._scheduleUpdate, false);\n    }\n  }\n\n  /**\n   * Schedule a throttled update to check if offsets need to be recalculated.\n   */\n  static _scheduleUpdate() {\n    window.removeEventListener('load', Affix._scheduleUpdate);\n\n    // Cancel a previous update if it exists.\n    if (Affix._updateId) {\n      window.cancelAnimationFrame(Affix._updateId);\n    }\n\n    // Throttle updates to once per frame.\n    Affix._updateId = window.requestAnimationFrame(Affix._handleImageLoad);\n  }\n\n  /**\n   * When an image loads, it could possibly change the layout/geometry of the\n   * entire page. Because Affix relies on offsets, everything must be\n   * updated here.\n   */\n  static _handleImageLoad() {\n    Affix._updateId = null;\n    Affix.documentHeight = document.body.offsetHeight;\n    Affix.viewportHeight = window.innerHeight;\n    Affix.update();\n  }\n\n  /**\n   * Batch update all instances. This method is more efficient because it syncs\n   * reads and writes to the DOM for each instance.\n   */\n  static update() {\n    const scrollY = window.pageYOffset;\n    const scrollPositions = Affix.instances.map(instance => instance.element.scrollTop);\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.unstick();\n      instance.reset();\n    });\n\n    // Read\n    Affix.instances.forEach((instance) => {\n      instance.read();\n    });\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.write();\n      instance.process(scrollY);\n    });\n\n    Affix.instances.forEach((instance, i) => {\n      instance.element.scrollTop = scrollPositions[i];\n    });\n  }\n\n  /**\n   * Remove an item from an array.\n   * @param {Array} arr Array to use.\n   * @param {*} item Item to remove.\n   * @return {*} Item removed.\n   */\n  static arrayRemove(arr, item) {\n    const index = arr.indexOf(item);\n    arr.splice(index, 1);\n    return item;\n  }\n}\n\nAffix.PROMOTION_RANGE = 200;\nAffix.instances = [];\nAffix._updateId = null;\nAffix.documentHeight = document.body.offsetHeight;\nAffix.viewportHeight = window.innerHeight;\nAffix._addImageLoadHandlers();\nAffix._resizeId = OdoWindowEvents.onResize(Affix._scheduleUpdate);\nwindow.addEventListener('load', Affix._scheduleUpdate);\n\nAffix.Classes = {\n  BASE: 'odo-affix',\n  AT_TOP: 'odo-affix--at-top',\n  AT_BOTTOM: 'odo-affix--at-bottom',\n};\n\nexport default Affix;\n"],"names":["Affix","element","_anchor","document","getElementById","getAttribute","this","Error","isStuck","isAtBottom","isPromoted","_customOverlap","_overlap","_maxHeight","_marginTop","_marginBottom","_top","_bottom","containerHeight","_scrollId","OdoScrollAnimation","add","process","bind","classList","Classes","BASE","style","overflowY","instances","push","update","read","rect","getBoundingClientRect","scrollY","window","pageYOffset","viewportHeight","innerHeight","asideHeight","offsetHeight","_asideWidth","offsetWidth","styles","getComputedStyle","parseFloat","marginTop","marginBottom","uiOverlap","Math","round","height","top","bottom","min","write","maxHeight","width","scrollTop","stick","stickToBottom","unstick","isInRange","isInPromotionRange","layerPromote","layerDemote","PROMOTION_RANGE","position","remove","AT_BOTTOM","AT_TOP","willChange","transform","reset","dispose","_resizeId","arrayRemove","_addImageLoadHandlers","images","getElementsByTagName","i","len","length","addEventListener","_scheduleUpdate","removeEventListener","_updateId","cancelAnimationFrame","requestAnimationFrame","_handleImageLoad","documentHeight","body","scrollPositions","map","instance","forEach","arr","item","index","indexOf","splice","fn","OdoWindowEvents","onResize"],"mappings":"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"}