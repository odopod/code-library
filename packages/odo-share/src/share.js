/**
 * Share component.
 *
 * @author Nathan Buchar
 */

import * as services from './services';

/**
 * The window name for all share windows spawned by Share
 */
const WINDOW_NAME = 'ShareWindow';
const noop = () => {};

class Share {
  /**
   * Prepares share components within the DOM.
   *
   * @constructor
   */
  constructor() {
    this.ClassName = {
      BASE: 'odo-share',
    };

    this.services = services;

    // An array of share data objects. These objects may contain information
    // regarding the root element, and beforeSend and afterSend functionality.
    this.shares = [];

    this._registerShareButtons();
  }

  /**
   * This registers all Share components that are
   * rendered to the DOM on page load. This will not prepare Share components
   * that are added to the DOM dynamically. These must be registered using the
   * public `add` method (@see add).
   *
   * @see _.add
   */
  _registerShareButtons() {
    // Pass an array of objects to the `add` method. These objects simply contain
    // an `element` key that references the DOM element.
    this.add(Array.from(
      document.querySelectorAll('.' + this.ClassName.BASE),
      element => ({ element }),
    ));
  }

  /**
   * Normalize an option.
   * @param {Object|Element} option Element or option object.
   * @return {?Object}
   */
  _normalizeOption(option) {
    if (option && option.nodeType === 1) {
      // A DOM element was passed in.
      return { element: option };
    } else if (option && option.element) {
      // A data object was passed in.
      return option;
    }

    return null;
  }

  /**
   * Normalize the options to an array of objects to add.
   * @param {Element|Array|Object} options An array of option objects, an option
   *     object, or an element.
   * @return {Array.<Object>} An array of new share data.
   */
  _normalizeOptions(options) {
    let items;

    if (Array.isArray(options)) {
      items = options.map(this._normalizeOption, this);
    } else {
      items = [this._normalizeOption(options)];
    }

    return items.filter(item => !!item);
  }

  /**
   * Iterates through each element passed into the method, prepares it and
   * pushes the completed data object to the `shares` array.
   *
   * @param {Element|Array|Object} options An array of option objects, an option
   *     object, or an element.
   */
  add(options) {
    const items = this._normalizeOptions(options);
    const newShares = [];

    items.forEach((data) => {
      data.listener = (evt) => {
        evt.preventDefault();
        this.share(data);
      };

      data.element.addEventListener('click', data.listener);

      this.shares.push(data);
      newShares.push(data);
    });

    return newShares;
  }

  /**
   * Performs the share operation. This will call the `before` method, reapply
   * any modified input, open the window, then perform the `after` functionality.
   *
   * @param {object} input - The input data for the share as defined by the user.
   * @param {object} output - The output data for the share as generated by the
   *   Share internals, such as the query  string, window properties, and
   *   parsed paramaters.
   * @param {object} service - The service configuration. @see ./services
   */
  _performShare(input, output, service) {
    const transformedData = input.before.call(this, output);

    const action = (arg) => {
      let windowObject;
      let options;
      let parsedOptions = output;

      // Reapply new data if applicable.
      if (arg !== undefined && arg !== null) {
        if (arg === false) {
          return;
        } else if ('data' in arg) {
          options = Object.assign(input, arg);
        } else {
          options = Object.assign(input, { data: arg });
        }

        parsedOptions = Share._parseInput(options, service);
      }

      if (service === this.services.email) {
        // Prevent opening empty window if sharing via email.
        this._navigate(parsedOptions.url);
      } else {
        // Open the share window.
        windowObject = this._open(parsedOptions.url, parsedOptions.name, service.Features);
      }

      // Call the `after` functionality.
      input.after.call(this, parsedOptions, windowObject);
    };

    // Return a promise from the `before` method to do something async.
    if (transformedData && transformedData.then) {
      transformedData.then(action);
    } else {
      action(transformedData);
    }
  }

  /**
   * Gets the service configuration from the given string.
   *
   * @param {object} data - Share input data.
   * @return {object|undefined} - The service configuration, or void if no service was
   *   defined.
   */
  _getService(data) {
    const service = data.service || (data.element && data.element.getAttribute('data-service'));

    if (this.services[service]) {
      return this.services[service];
    }

    return undefined;
  }

  /**
   * Parses the given input and exports the technical output based
   * on the service schema. This includes items such as the query string, window
   * data, and params.
   *
   * @param {object} input - Share input data.
   * @param {object} service - The service configuration.
   * @return {object} output - The parsed output.
   * @see _parseparamsFromInput
   * @see _getQueryString
   * @see _constructWindowData
   */
  static _parseInput(input, service) {
    const params = Share._parseParamsFromInput(input, service);
    const queryString = Share._getQueryString(params);

    return {
      params,
      queryString,
      url: service.BASE + queryString,
      name: WINDOW_NAME,
    };
  }

  /**
   * Parse the parameters from the given input and service schema. Defining a
   * service schema allows us to always use "url" for all our share buttons,
   * regardless of their service, as long as the proper key is defined in its
   * respective parameter schema.
   *
   * If a parameter has a `parse` method within the object, this method will be
   * called and will pass in the input value for that particular parameter. This
   * allows us to customize how a parameter is parsed on a per-parameter and per-
   * service basis without adding needless code within conditional blocks below.
   *
   * Order of priorities:
   *   input value > `data` attributes (if applicable) > default > `void`
   *
   * @param {object} input - Share input data.
   * @param {object} service - The service configuration.
   * @return {object} obj - The parsed parameters.
   */
  static _parseParamsFromInput(input, service) {
    const elementData = input.element ? input.element.dataset : {};
    const { data } = input;
    const obj = {};

    // Iterate through each valid paramater for the given service.
    Object.keys(service.params).forEach((param) => {
      const config = service.params[param];
      const { friendly } = config;
      let value = null;

      // Check if the parameter was defined when `share` was called.
      if (friendly in data) {
        value = data[friendly];
      } else if (friendly in elementData) {
        // Check if the parameter is defined as a data attribute on the element.
        value = elementData[friendly];
      } else if (config.default) {
        // The param was not defined; Check for default values.
        value = config.default;
      }

      if (value) {
        // Parse the parameter and set its value.
        obj[param] = (config.parse ? config.parse(value) : value).toString();
      }
    });

    return obj;
  }

  /**
   * Assembles the query string from an enumerated param object.
   *
   * For example { foo: 'bar', baz: 'qux' } => "?foo=bar&baz=qux"
   *
   * @param {object} data - Parameter data.
   * @return {string} query - The finalized query string.
   */
  static _getQueryString(data) {
    let base = '';

    // The mailto: format requires the `to` to be first, before the `?`.
    if (data.to) {
      base = data.to;
      delete data.to;
    }

    const pairs = Object.keys(data).map(param => `${param}=${data[param]}`);
    return `${base}?${pairs.join('&')}`;
  }

  /* istanbul ignore next */
  /**
   * Opens a new browser window.
   *
   * @param {string} url - The URL to be loaded in the newly opened window.
   * @param {string} windowName - A string name for the new window. The name
   *   should not contain any whitespace characters. NOTE that windowName does not
   *   specify the title of the new window. If a window with the same name already
   *   exists, then the URL is loaded into the existing window.
   * @return {object|null} - A reference to the newly created window. If the call
   *   failed, it will be null. The reference can be used to access properties and
   *   methods of the new window provided it complies with Same origin policy
   *   security requirements.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open}
   */
  _open(url, windowName, windowFeatures = '') {
    return window.open(url, windowName, windowFeatures);
  }

  /* istanbul ignore next */
  /**
   * Navigate to a new location within the same tab. This is used to open the
   * user's default email app.
   * @param {string} url mailto url.
   */
  _navigate(url) {
    window.location.assign(url);
  }

  /**
   * Initiate sharing. Extend the default options, fetch the service,
   * parse the input, then perform the share.
   *
   * @example
   *   Share.share({
   *     service: 'twitter',
   *     data: {
   *       url: 'http://odopod.com/'
   *       text: 'Check this out!',
   *       via: 'Nurun',
   *       hashtags: ['rad', 'odoshare']
   *     }
   *   });
   *
   * @param {object} options - Share options.
   * @return {boolean} - Will return true if the share was successfull.
   */
  share(options) {
    const opts = Object.assign({}, Share.Options, options);

    // Fetch the service config from the string provided.
    const service = this._getService(opts);

    // The service could not be determined or was not defined; Exit early.
    if (!service) {
      return false;
    }

    // Parse the output (params, query string, etc) from the data provided.
    const output = Share._parseInput(opts, service);

    // Perform the share operation.
    this._performShare(opts, output, service);

    return true;
  }

  /**
   * Disposes of all references and event listeners to the share
   * button. To reverse this, you must call `.add` and pass in the element and
   * options again.
   *
   * @param {Element} element - A reference to the share button's element.
   * @return {number|undefined} - If a share button was disposed, this will return `1`,
   *   (the length of the number of items disposed of), otherwise this will not
   *   return.
   */
  dispose(element) {
    for (let i = 0; i < this.shares.length; i++) {
      const data = this.shares[i];
      if (data.element === element) {
        data.element.removeEventListener('click', data.listener);
        return this.shares.splice(i, 1).length;
      }
    }

    return undefined;
  }
}

/**
 * Default share input options. These may be overwritten by the user.
 */
Share.Options = {
  data: {},
  before: noop,
  after: noop,
};

export default new Share();
